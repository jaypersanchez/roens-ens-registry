<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ENS Registry UI</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    input, button { margin: 5px; padding: 5px; }
    #output { margin-top: 20px; }
  </style>
</head>
<body>
  <h1>ENS Registry</h1>

  <!-- Domain Registration Section -->
  <div>
    <h2>Register Domain</h2>
    <label for="domainInput">Domain name:</label>
    <input type="text" id="domainInput" placeholder="example" />
    <button id="registerBtn">Register Domain</button>
  </div>

  <!-- Domain Query Section -->
  <div>
    <h2>Query Domain</h2>
    <label for="queryInput">Domain name:</label>
    <input type="text" id="queryInput" placeholder="example" />
    <button id="queryBtn">Check Owner</button>
  </div>

  <!-- Output Section -->
  <div id="output"></div>

  <!-- Include ethers.js from a CDN -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

  <script>
    let contractAddress = "";
    const ensRegistryAbi = [
      {
        "inputs": [
          { "internalType": "bytes32", "name": "node", "type": "bytes32" },
          { "internalType": "address", "name": "owner", "type": "address" }
        ],
        "name": "setOwner",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          { "internalType": "bytes32", "name": "node", "type": "bytes32" }
        ],
        "name": "getOwner",
        "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "anonymous": false,
        "inputs": [
          { "indexed": true, "internalType": "bytes32", "name": "node", "type": "bytes32" },
          { "indexed": false, "internalType": "address", "name": "owner", "type": "address" }
        ],
        "name": "NameRegistered",
        "type": "event"
      }
    ];

    // Helper: convert a string to bytes32.
    function toBytes32(text) {
      const bytes = ethers.utils.toUtf8Bytes(text);
      if (bytes.length > 31) {
        alert("Text too long! Must be less than 32 bytes.");
        return null;
      }
      return ethers.utils.hexZeroPad(bytes, 32);
    }

    // Load addresses from addresses.json in the root.
    async function loadAddresses() {
      try {
        const response = await fetch("addresses.json");
        if (!response.ok) {
          throw new Error("Failed to load addresses.json");
        }
        const addresses = await response.json();
        contractAddress = addresses.ENSRegistry;
        console.log("Loaded ENSRegistry address:", contractAddress);
      } catch (error) {
        console.error("Error loading addresses:", error);
      }
    }

    // Connect wallet
    async function connect() {
      if (!window.ethereum) {
        alert("MetaMask is required to interact with this dApp.");
        throw new Error("No Ethereum provider");
      }
      const provider = new ethers.providers.Web3Provider(window.ethereum);
      const desiredChainId = 31337; // change if needed
      const network = await provider.getNetwork();
      if (network.chainId !== desiredChainId) {
        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: ethers.utils.hexValue(desiredChainId) }]
          });
        } catch (switchError) {
          console.error("Error switching network:", switchError);
          alert("Please switch your MetaMask network to the desired network.");
          throw new Error("Incorrect network");
        }
      }
      await window.ethereum.request({ method: "eth_requestAccounts" });
      return provider;
    }

    // Register Domain: calls setOwner(node, userAddress)
    async function registerDomain() {
      await loadAddresses();
      if (!contractAddress) {
        alert("Contract address not loaded.");
        return;
      }
      const provider = await connect();
      const signer = provider.getSigner();
      const ensRegistry = new ethers.Contract(contractAddress, ensRegistryAbi, signer);
      const domain = document.getElementById("domainInput").value.trim();
      const node = toBytes32(domain);
      if (!node) return;
      try {
        document.getElementById("output").innerText = "Sending transaction...";
        const tx = await ensRegistry.setOwner(node, await signer.getAddress());
        await tx.wait();
        document.getElementById("output").innerText = `Domain "${domain}" registered successfully!`;
      } catch (err) {
        document.getElementById("output").innerText = "Error: " + err.message;
        console.error(err);
      }
    }

    // Query Domain: calls getOwner(node)
    async function queryDomain() {
      await loadAddresses();
      if (!contractAddress) {
        alert("Contract address not loaded.");
        return;
      }
      const provider = await connect();
      const ensRegistry = new ethers.Contract(contractAddress, ensRegistryAbi, provider);
      const domain = document.getElementById("queryInput").value.trim();
      const node = toBytes32(domain);
      if (!node) return;
      try {
        const owner = await ensRegistry.getOwner(node);
        document.getElementById("output").innerText = owner === ethers.constants.AddressZero 
          ? `Domain "${domain}" is unregistered.` 
          : `Domain "${domain}" is owned by: ${owner}`;
      } catch (err) {
        document.getElementById("output").innerText = "Error: " + err.message;
        console.error(err);
      }
    }

    // Set up event listeners.
    document.getElementById("registerBtn").addEventListener("click", registerDomain);
    document.getElementById("queryBtn").addEventListener("click", queryDomain);
    // Load addresses on page load.
    window.addEventListener("load", loadAddresses);
  </script>
</body>
</html>
